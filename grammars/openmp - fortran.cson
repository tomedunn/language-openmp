'comment': 'OpenMP rules for Fortran.'
'name': 'Fortran - OpenMP'
'scopeName': 'source.openmp'
'fileTypes': []
'injectionSelector': 'source.fortran comment'
'patterns': [
  {
    'name': 'meta.openmp.directive'
    'begin': '(?i)(\\$omp)\\b'
    'beginCaptures':
      '1': 'name': 'keyword.control.openmp'
    'end': '(?=[$\\n])'
    'patterns':[
      {'include': '#environment-variables'}
      {'include': '#intrinsic-functions'}
      {'include': '#operators'}
      {'include': '#end-directives'}
      {'include': '#directives'}
    ]
  }
]
'repository':
  # directives:
  'directives':
    'patterns':[
      {
        'comment': 'do-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(do(\\s*simd)?)\\b'
      }
      {
        'comment': 'declare-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(declare(\\s*reduction|\\s*simd|\\s*target)?)\\b'
      }
      {
        'comment': 'distribute-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(distribute(\\s*parallel\\s*do)?(\\s*simd)?)\\b'
      }
      {
        'comment': 'parallel-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(parallel(\\s*do(\\s*simd)?|\\s*sections|\\s*workshare)?)\\b'
      }
      {
        'comment': 'target-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(target(\\s*data|teams(\\s*distribute(\\s*parallel\\s*do)?(\\s*simd)?)?|\\s*update)?)\\b'
      }
      {
        'comment': 'teams-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(teams(\\s*distribute(\\s*parallel\\s*do)?(\\s*simd)?)?)\\b'
      }
      {
        'comment': 'shared-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(shared)\\b'
      }
    ]
  # end directives:
  'end-directives':
    'patterns':[
      {
        'comment': 'end-atomic-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*atomic)\\b'
      }
      {
        'comment': 'end-critical-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*critical)\\b'
      }
      {
        'comment': 'end-distribute-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*distribute(\\s*parallel\\s*do)?(\\s*simd)?)\\b'
      }
      {
        'comment': 'end-do-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*do(\\s*simd)?)\\b'
      }
      {
        'comment': 'end-master-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*master)\\b'
      }
      {
        'comment': 'end-ordered-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*ordered)\\b'
      }
      {
        'comment': 'end-parallel-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*parallel(\\s*do(\\s*simd)?|\\s*sections|\\s*workshare)?)\\b'
      }
      {
        'comment': 'end-sections-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*sections)\\b'
      }
      {
        'comment': 'end-simd-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*simd)\\b'
      }
      {
        'comment': 'end-single-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*single)\\b'
      }
      {
        'comment': 'end-target-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*target(\\s*data|\\s*teams(\\s*distribute(\\s*parallel\\s*do)?(\\s*simd)?)?|\\s*update)?)\\b'
      }
      {
        'comment': 'end-task-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*task(\\s*group)?)\\b'
      }
      {
        'comment': 'end-teams-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*teams(\\s*distribute(\\s*parallel\\s*do)?(\\s*simd)?)?)\\b'
      }
      {
        'comment': 'end-workshare-directive'
        'name': 'keyword.control.openmp'
        'match': '(?i)\\b(end\\s*workshare)\\b'
      }
    ]
  # environment variables:
  'environment-variables':
    'patterns':[
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_dynamic)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_nested)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_num_threads)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_schedule)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_proc_bind)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_stacksize)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_wait_policy)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_thread_limit)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_max_active_levels)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_places)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_cancelation)\\b'
      }
      {
        'name': 'variable.parameter.openmp'
        'match': '(?i)\\b(omp_default_device)\\b'
      }
    ]
  # functions:
  'intrinsic-functions':
    'patterns':[
      {
        'begin': '(?i)\\b(omp_get_(active_levels|cancelation|level|proc_bind|thread_limit))\\s*(\\()'
        'beginCaptures':
          '1': 'name': 'support.function.intrinsic.openmp'
          '2': 'name': 'punctuation.parentheses.left.openmp'
        'end': '(\\))'
        'endCaptures':
          '1': 'name': 'punctuation.parentheses.left.openmp'
        'patterns':[
          {'include': '$self'}
        ]
      }
      {
        'begin': '(?i)\\b(omp_(get|set)_(default_device|dynamic|max_active_levels|nested|num_threads|schedule))\\s*(\\()'
        'beginCaptures':
          '1': 'name': 'support.function.intrinsic.openmp'
          '2': 'name': 'punctuation.parentheses.left.openmp'
        'end': '(\\))'
        'endCaptures':
          '1': 'name': 'punctuation.parentheses.left.openmp'
        'patterns':[
          {'include': '$self'}
        ]
      }
    ]
  # operators:
  'operators':
    'comment': 'Operator that allows a line to be continued on the next line.'
    'patterns':[
      {
        'match': '\\G\\s*(&)'
        'captures':
          '1': 'name': 'keyword.operator.line-continuation.openmp'
      }
      {
        'contentName': 'meta.line-continuation.openmp'
        'begin': '\\s*(&)'
        'beginCaptures':
          '1': 'name': 'keyword.operator.line-continuation.openmp'
        'end': '(?i)^(?:\\s*(&))?'
        'endCaptures':
          '1': 'name': 'keyword.operator.line-continuation.openmp'
        'patterns':[
          {
            'name': 'invalid.error.openmp'
            'match': '\\S*'
          }
        ]
      }
    ]
